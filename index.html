<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        .navbar { padding: 10px 15px; }
        .navbar h1 { font-size: 1.5rem; color: white; margin: 0; }
        
        .offcanvas-body ul { list-style: none; padding: 0; }
        .offcanvas-body li { 
            cursor: pointer; 
            padding: 10px; 
            border-bottom: 1px solid #ddd; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .offcanvas-body li.dragging {
            opacity: 0.5;
            background: #e9ecef;
        }
        .list-name {
            flex-grow: 1;
        }
        .list-name:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.5);
            border-radius: 4px;
        }

        .list-buttons {
            display: flex;
            align-items: center;
        }
        .edit-list-btn, .save-list-btn, .cancel-list-btn, .delete-list-btn { 
            margin-left: 10px; 
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            font-size: 1rem;
        }

        /* Styles for the new list drag handle */
        .drag-handle-list {
            cursor: grab;
            margin-right: 10px;
            color: #888;
            font-size: 1.2rem;
            line-height: 1;
        }
        .drag-handle-list:active {
            cursor: grabbing;
        }

        #main { padding: 15px; box-sizing: border-box; }
        #add-item { display: flex; margin-bottom: 15px; }
        #add-item input { flex: 1; padding: 10px; }
        #add-item button { padding: 10px; }
        #items { list-style: none; padding: 0; margin: 0; }
        #items li { 
            background: #eee; 
            margin: 10px 0; 
            padding: 10px; 
            display: flex; 
            align-items: center; 
            cursor: grab; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
        }
        #items li.dragging { opacity: 0.5; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .delete-btn { margin-left: 10px; cursor: pointer; }
        
        .item-number {
            font-weight: bold;
            margin-right: 10px;
            min-width: 25px;
            text-align: right;
        }
        .item-text-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .item-text {
            flex-grow: 1;
        }
        .item-text:focus {
            outline: 2px solid #0d6efd;
            border-radius: 4px;
        }

        #export, #import { margin: 10px 0; display: block; }
        #import-file { display: none; }
    </style>
</head>
<body>
    <header class="navbar bg-dark navbar-dark d-flex justify-content-between align-items-center">
        <h1 id="header-list-name">To-Do App</h1>
        <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasMenu" aria-controls="offcanvasMenu">
            <span class="navbar-toggler-icon"></span>
        </button>
    </header>

    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasMenu" aria-labelledby="offcanvasMenuLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="offcanvasMenuLabel">Lists</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <ul id="lists"></ul>
            <div class="input-group mt-3 mb-3">
                <input type="text" id="new-list-name" class="form-control" placeholder="New list name">
                <button id="add-list" class="btn btn-primary">Add List</button>
            </div>
            <hr>
            <button id="export" class="btn btn-outline-secondary w-100">Export JSON</button>
            <label for="import-file" class="btn btn-outline-secondary w-100 mt-2">Import JSON</label>
            <input type="file" id="import-file" accept=".json">
        </div>
    </div>

    <div id="main" class="container">
        <div id="add-item" class="input-group mb-3">
            <input id="new-item" type="text" class="form-control" placeholder="New item">
            <button id="add-btn" class="btn btn-success">Add</button>
        </div>
        <ul id="items"></ul>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        let data = { lists: [], items: [] };
        let currentListIndex = 0;
        let nextListId = 1;
        let nextItemId = 1;

        function loadData() {
            const saved = localStorage.getItem('todoData');
            if (saved) {
                data = JSON.parse(saved);
                nextListId = Math.max(...data.lists.map(l => l.id), 0) + 1;
                nextItemId = Math.max(...data.items.map(i => i.id), 0) + 1;
            } else {
                data.lists.push({ id: nextListId++, name: 'Default List', position: 1 });
            }
            renderLists();
            renderItems();
            updateHeadings();
        }

        function saveData() {
            localStorage.setItem('todoData', JSON.stringify(data));
        }

        function updateHeadings() {
            const currentList = data.lists[currentListIndex];
            if (currentList) {
                document.title = currentList.name + ' | To-Do App';
                document.getElementById('header-list-name').textContent = currentList.name;
            } else {
                document.title = 'To-Do App';
                document.getElementById('header-list-name').textContent = 'To-Do App';
            }
        }
        
        function deleteList(listId) {
            data.lists = data.lists.filter(l => l.id !== listId);
            data.items = data.items.filter(i => i.list_id !== listId);
        
            if (data.lists.length > 0) {
                const newCurrentList = data.lists[0];
                currentListIndex = 0;
            } else {
                data.lists.push({ id: nextListId++, name: 'Default List', position: 1 });
                currentListIndex = 0;
            }
        
            saveData();
            renderLists();
            renderItems();
            updateHeadings();
        }

        function renderLists() {
            const lists = document.getElementById('lists');
            lists.innerHTML = '';
            // Store the ID of the current list to maintain selection after re-render
            const currentListId = data.lists[currentListIndex]?.id;

            data.lists.sort((a, b) => a.position - b.position).forEach(list => {
                const li = document.createElement('li');
                li.draggable = true; // Make the list item draggable
                li.dataset.listId = list.id;

                // Create and add the drag handle icon
                const dragHandle = document.createElement('span');
                dragHandle.textContent = '≡'; // A common drag icon
                dragHandle.className = 'drag-handle-list';
                li.appendChild(dragHandle);

                const listNameSpan = document.createElement('span');
                listNameSpan.textContent = list.name;
                listNameSpan.classList.add('list-name'); 
                li.appendChild(listNameSpan);
                
                const listButtons = document.createElement('div');
                listButtons.classList.add('list-buttons');

                const editBtn = document.createElement('span');
                editBtn.textContent = '✏️';
                editBtn.className = 'edit-list-btn';
                listButtons.appendChild(editBtn);

                const deleteBtn = document.createElement('span');
                deleteBtn.textContent = '🗑';
                deleteBtn.className = 'delete-list-btn';
                listButtons.appendChild(deleteBtn);

                li.appendChild(listButtons);

                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    const initialName = listNameSpan.textContent;
                    listNameSpan.contentEditable = true;
                    listNameSpan.focus();
                    
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.selectNodeContents(listNameSpan);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    const saveBtn = document.createElement('span');
                    saveBtn.textContent = '✔️';
                    saveBtn.className = 'save-list-btn';
                    
                    const cancelBtn = document.createElement('span');
                    cancelBtn.textContent = '❌';
                    cancelBtn.className = 'cancel-list-btn';

                    listButtons.replaceChild(saveBtn, editBtn);
                    listButtons.insertBefore(cancelBtn, saveBtn);

                    saveBtn.onclick = (e) => {
                        e.stopPropagation();
                        const newName = listNameSpan.textContent.trim();
                        if (newName) {
                            list.name = newName;
                            saveData();
                        }
                        listNameSpan.contentEditable = false;
                        listButtons.replaceChild(editBtn, saveBtn);
                        listButtons.removeChild(cancelBtn);
                        renderLists();
                        updateHeadings();
                    };

                    cancelBtn.onclick = (e) => {
                        e.stopPropagation();
                        listNameSpan.textContent = initialName;
                        listNameSpan.contentEditable = false;
                        listButtons.replaceChild(editBtn, saveBtn);
                        listButtons.removeChild(cancelBtn);
                        renderLists();
                        updateHeadings();
                    };
                };

                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteList(list.id);
                };
                
                li.onclick = (e) => {
                    // Prevent list selection when clicking on buttons or handle
                    if (e.target.classList.contains('drag-handle-list') || e.target.closest('.list-buttons')) {
                        return;
                    }
                    currentListIndex = data.lists.findIndex(l => l.id === list.id);
                    updateHeadings();
                    renderItems();
                    const offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('offcanvasMenu'));
                    if (offcanvas) offcanvas.hide();
                };
                
                lists.appendChild(li);
            });
            // Update currentListIndex to point to the correct list after sorting/rendering
            currentListIndex = data.lists.findIndex(l => l.id === currentListId);
            if (currentListIndex === -1) currentListIndex = 0;

            initListDragAndDrop(); // Initialize drag and drop for the lists
        }

        function renderItems() {
            const items = document.getElementById('items');
            items.innerHTML = '';
            const currentList = data.lists[currentListIndex];
            if (!currentList) {
                items.innerHTML = '<li class="list-group-item">No items. Add a list first.</li>';
                return;
            }
            data.items
                .filter(item => item.list_id === currentList.id)
                .sort((a, b) => a.position - b.position)
                .forEach((item, index) => {
                    const li = document.createElement('li');
                    li.draggable = true;
                    li.dataset.itemId = item.id;

                    const itemContainer = document.createElement('div');
                    itemContainer.classList.add('item-text-container');
                    
                    const itemNumber = document.createElement('span');
                    itemNumber.classList.add('item-number');
                    itemNumber.textContent = `${index + 1}.`;
                    itemContainer.appendChild(itemNumber);

                    const text = document.createElement('span');
                    text.textContent = item.text;
                    text.classList.add('item-text');
                    text.contentEditable = false;
                    itemContainer.appendChild(text);
                    li.appendChild(itemContainer);

                    text.addEventListener('click', (e) => {
                        if (text.contentEditable === 'true') return;
                        text.contentEditable = true;
                        text.focus();
                    });
                    
                    text.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            text.blur();
                        }
                    });

                    text.onblur = () => {
                        text.contentEditable = false;
                        const newText = text.textContent.trim();
                        if (newText) {
                            item.text = newText;
                            saveData();
                        } else {
                            text.textContent = item.text; // Revert if empty
                        }
                    };
                    
                    const deleteBtn = document.createElement('span');
                    deleteBtn.textContent = '🗑';
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.onclick = () => {
                        data.items = data.items.filter(i => i.id !== item.id);
                        saveData();
                        renderItems();
                    };
                    li.appendChild(deleteBtn);
                    items.appendChild(li);
                });
            initDragAndDrop();
        }
        
        // NEW FUNCTION for dragging and dropping lists
        function initListDragAndDrop() {
            const listsContainer = document.getElementById('lists');
            let dragSrcEl = null;

            function handleDragStart(e) {
                // Only allow dragging from the handle
                if (!e.target.classList.contains('drag-handle-list')) {
                    e.preventDefault();
                    return;
                }
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', this.innerHTML);
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                e.preventDefault();
                return false;
            }

            function handleDrop(e) {
                e.stopPropagation(); // stops the browser from redirecting.
                if (dragSrcEl !== this) {
                    const allLists = Array.from(listsContainer.children);
                    const srcIndex = allLists.indexOf(dragSrcEl);
                    const destIndex = allLists.indexOf(this);

                    const activeListIdBeforeReorder = data.lists[currentListIndex]?.id;
                    
                    const [movedItem] = data.lists.splice(srcIndex, 1);
                    data.lists.splice(destIndex, 0, movedItem);

                    data.lists.forEach((list, idx) => list.position = idx + 1);
                    currentListIndex = data.lists.findIndex(l => l.id === activeListIdBeforeReorder);
                    
                    saveData();
                    renderLists();
                }
                return false;
            }

            function handleDragEnd() {
                Array.from(listsContainer.children).forEach(item => {
                    item.classList.remove('dragging');
                });
            }

            // Touch event handling for lists
            let touchElement = null;
            let hasMoved = false;

            listsContainer.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('drag-handle-list')) {
                    touchElement = e.target.closest('li');
                    hasMoved = false;
                }
            }, { passive: true });

            listsContainer.addEventListener('touchmove', (e) => {
                if (!touchElement) return;
                hasMoved = true;
                touchElement.classList.add('dragging');
                
                const touchY = e.touches[0].clientY;
                const hoverElement = document.elementFromPoint(e.touches[0].clientX, touchY);
                const hoverLi = hoverElement ? hoverElement.closest('li') : null;

                if (hoverLi && hoverLi !== touchElement && listsContainer.contains(hoverLi)) {
                    const allLists = Array.from(listsContainer.children);
                    const srcIndex = allLists.indexOf(touchElement);
                    const destIndex = allLists.indexOf(hoverLi);
                    if (srcIndex < destIndex) {
                        listsContainer.insertBefore(touchElement, hoverLi.nextSibling);
                    } else {
                        listsContainer.insertBefore(touchElement, hoverLi);
                    }
                }
            });

            listsContainer.addEventListener('touchend', () => {
                if (!touchElement) return;
                touchElement.classList.remove('dragging');
                if (hasMoved) {
                    const activeListIdBeforeReorder = data.lists[currentListIndex]?.id;
                    const newOrderIds = Array.from(listsContainer.children).map(li => parseInt(li.dataset.listId));
                    data.lists.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));

                    data.lists.forEach((list, index) => list.position = index + 1);
                    currentListIndex = data.lists.findIndex(l => l.id === activeListIdBeforeReorder);

                    saveData();
                    renderLists();
                }
                touchElement = null;
            });
            
            Array.from(listsContainer.children).forEach(item => {
                item.addEventListener('dragstart', handleDragStart, false);
                item.addEventListener('dragover', handleDragOver, false);
                item.addEventListener('drop', handleDrop, false);
                item.addEventListener('dragend', handleDragEnd, false);
            });
        }

        function initDragAndDrop() {
            const items = document.getElementById('items');
            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.itemId);
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }

            function handleDrop(e) {
                e.preventDefault();
                if (dragSrcEl !== this) {
                    const srcId = parseInt(dragSrcEl.dataset.itemId);
                    const destId = parseInt(this.dataset.itemId);
                    const srcItem = data.items.find(i => i.id === srcId);
                    const destItem = data.items.find(i => i.id === destId);
                    const srcIndex = data.items.indexOf(srcItem);
                    const destIndex = data.items.indexOf(destItem);
                    data.items.splice(destIndex, 0, data.items.splice(srcIndex, 1)[0]);
                    
                    const currentListItems = data.items.filter(i => i.list_id === data.lists[currentListIndex].id);
                    currentListItems.forEach((item, idx) => item.position = idx + 1);

                    saveData();
                    renderItems();
                }
                dragSrcEl.classList.remove('dragging');
            }

            function handleDragEnd() {
                this.classList.remove('dragging');
            }

            let touchElement = null;
            let hasMoved = false;

            items.addEventListener('touchstart', (e) => {
                touchElement = e.target.closest('li');
                hasMoved = false;
                if (touchElement) {
                    touchElement.classList.add('dragging');
                }
            });

            items.addEventListener('touchmove', (e) => {
                e.preventDefault();
                hasMoved = true;
                if (touchElement) {
                    const touchY = e.touches[0].clientY;
                    const hoverElement = document.elementFromPoint(e.touches[0].clientX, touchY);
                    const hoverLi = hoverElement ? hoverElement.closest('li') : null;
                    if (hoverLi && hoverLi !== touchElement) {
                        const rect = hoverLi.getBoundingClientRect();
                        const next = (touchY - rect.top) / rect.height > 0.5;
                        items.insertBefore(touchElement, next ? hoverLi.nextSibling : hoverLi);
                    }
                }
            });

            items.addEventListener('touchend', () => {
                if (touchElement) {
                    touchElement.classList.remove('dragging');
                    if (hasMoved) {
                        const newOrder = Array.from(items.children).map(li => parseInt(li.dataset.itemId));
                        const reorderedItems = newOrder.map(id => data.items.find(i => i.id === id));
                        
                        const otherItems = data.items.filter(i => i.list_id !== data.lists[currentListIndex].id);
                        data.items = otherItems.concat(reorderedItems);

                        reorderedItems.forEach((item, index) => item.position = index + 1);
                        saveData();
                        renderItems();
                    }
                    touchElement = null;
                }
            });

            Array.from(items.children).forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }
        
        function addItem() {
            const textInput = document.getElementById('new-item');
            const text = textInput.value.trim();
            if (text) {
                const capitalizedText = text.charAt(0).toUpperCase() + text.slice(1);
                data.items.push({
                    id: nextItemId++,
                    list_id: data.lists[currentListIndex].id,
                    text: capitalizedText,
                    position: data.items.filter(i => i.list_id === data.lists[currentListIndex].id).length + 1
                });
                saveData();
                renderItems();
                textInput.value = '';
            }
        }
        
        document.getElementById('add-list').onclick = () => {
            const name = document.getElementById('new-list-name').value.trim();
            if (name) {
                data.lists.push({ id: nextListId++, name, position: data.lists.length + 1 });
                saveData();
                renderLists();
                document.getElementById('new-list-name').value = '';
            }
        };

        document.getElementById('add-btn').onclick = addItem;
        document.getElementById('new-item').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addItem();
            }
        });
        
        document.getElementById('export').onclick = () => {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'todo_data.json';
            a.click();
        };

        document.getElementById('import-file').onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    data = JSON.parse(ev.target.result);
                    nextListId = Math.max(...data.lists.map(l => l.id), 0) + 1;
                    nextItemId = Math.max(...data.items.map(i => i.id), 0) + 1;
                    saveData();
                    renderLists();
                    renderItems();
                };
                reader.readAsText(file);
            }
        };

        loadData();
    </script>
</body>
</html>